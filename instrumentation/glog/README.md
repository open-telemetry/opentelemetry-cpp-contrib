# glog OpenTelemetry sink

## Features

- Supports glog log sink
- Supports OpenTelemetry SDK without any changes

## Requirements

- Current release tested only with Ubuntu 20.04.6 LTS
- OpenTelemetry >= v1.12.0 
- glog >= v0.3.5

### Usage

Please see below for [manual build](#build). Otherwise please use one of the [released versions](https://github.com/open-telemetry/opentelemetry-cpp-contrib/releases).

### Configuration

The OpenTelemetry sink can be configured in much the same way as any other glog sink.

This is done by using the pair of macros specifically available for this purpose and pass to them an object of the `OpenTelemetrySink`. This also means that any other macro that was relying of verbose or debug logging will not have an equivalent that can be used with the sink and, consequently, only severity levels FATAL, ERROR, WARNING and INFO are available for use with the sink. 

```cpp
#include <opentelemetry/instrumentation/glog/sink.h>

google::OpenTelemetrySink sink;
LOG_TO_SINK/*_AND_TO_LOGFILE*/(&sink, INFO) << "This message will be processed and logged.";
LOG_TO_SINK_BUT_NOT_TO_LOGFILE(&sink, INFO) << "This message will be processed but not logged.";
```

For more details, refer to the [examples](#examples) section.

## Development

### Requirements

- C++14
- CMake 3.x
- [OpenTelemetry-cpp](https://github.com/open-telemetry/opentelemetry-cpp)
- [glog](https://github.com/google/glog)
- vcpkg **_(optional)_**

### Build
As a preparation step, both dependencies need to be built and available in the development environment. This can be a manual build, by following the instructions for the corresponding package, or one could opt to use a package management system such as _vcpkg_ or _conan_.

Assuming the packages are available on the system, configure CMake as usual:

```bash
mkdir build
cd build
cmake [path/to/opentelemetry-cpp-contrib]/instrumentation/glog -DBUILD_SHARED_LIBS=ON
make
```

Optionally, if the packages were provided via vcpkg, pass in to the _cmake_ command above the flag `-DCMAKE_TOOLCHAIN_FILE=${VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake` where VCPKG_ROOT is where vcpkg was installed. 

Now, simply link the target source (i.e., main.cc in the example below) against _glog_ and  _opentelemetry_glog_:

```bash
g++ main.cc -lglog -lopentelemetry_glog -o main
```

### Installation ###

When configuring the build, if the flag `-DOPENTELEMETRY_INSTALL=ON` is passed, CMake will ensure to set up the install scripts. Once the build succeeds, running `make install` will make the sink header(s) and library available under the usr include and lib directories, respectively.

### Testing

A small suite of unit tests is available under the `test` directory. It can be enabled by passing `-DBUILD_TESTING=ON` when configuring CMake, which will generate an executable called **sink_test**.

### Examples

An example executable is available to test the functionality of the sink. For ease of setup, it uses the _OStreamLogRecordExporter_ to display the contents of the intercepted glog message as an OTel _LogRecord_. It can be generated by adding `-DWITH_EXAMPLES=ON` when configuring CMake, which will ultimately produce the **otel_sink_example** executable.

Running  `./otel_sink_example` would produce an output similar to below:

```
{
  timestamp          : 1703883948145567000
  observed_timestamp : 1703883948145613889
  severity_num       : 9
  severity_text      : INFO
  body               : This message will be processed and logged.
  resource           :
    service.name: unknown_service
    telemetry.sdk.version: 1.12.0
    telemetry.sdk.name: opentelemetry
    telemetry.sdk.language: cpp
  attributes         :
    code.lineno: 77
    code.filepath: /otel-contrib/instrumentation/glog/example/main.cc
  event_id           : 0
  event_name         :
  trace_id           : 7753a4ce0faf85dcae9fbcfb4b14a63c
  span_id            : 9e2a19e324de6986
  trace_flags        : 01
  scope              :
    name             : glog
    version          :
    schema_url       :
    attributes       :
}
{
  timestamp          : 1703883948145762000
  observed_timestamp : 1703883948145776966
  severity_num       : 9
  severity_text      : INFO
  body               : This message will be processed but not logged.
  resource           :
    service.name: unknown_service
    telemetry.sdk.version: 1.12.0
    telemetry.sdk.name: opentelemetry
    telemetry.sdk.language: cpp
  attributes         :
    code.lineno: 78
    code.filepath: /otel-contrib/instrumentation/glog/example/main.cc
  event_id           : 0
  event_name         :
  trace_id           : 7753a4ce0faf85dcae9fbcfb4b14a63c
  span_id            : 9e2a19e324de6986
  trace_flags        : 01
  scope              :
    name             : glog
    version          :
    schema_url       :
    attributes       :
}
==============================
Contents of log file ./otel_sink_example.INFO:
...
I20231229 21:05:48.143756 23775 main.cc:72] This message will be ignored and logged by default.
I20231229 21:05:48.145527 23775 main.cc:73] This message will be ignored but logged.
I20231229 21:05:48.145567 23775 main.cc:77] This message will be processed and logged.

==============================
```

The above excerpt shows which logs are included in the log file and which ones are processed by Opentelemetry:

- For instance, calling `LOG(INFO)` will output "**This message will be processed and logged.**" to console and to file but will not be intercepted by the log sink.

- Similarly, calling `LOG_TO_SINK(nullptr, INFO)` will output "**This message will be ignored but logged.**" onto the log file but will be ignored otherwise since the sink provided was a null pointer.

- However, calling `LOG_TO_SINK(&sink, INFO)` will output "**This message will be processed and logged.**" and will also be intercepted by the OTel sink.

- Finally, calling `LOG_TO_SINK_BUT_NOT_TO_LOGFILE(&sink, INFO)` will produce "**This message will be processed but not logged.**" but will not be output to the log file.

This example will also output a span with the same ID as the log record(s), to showcase how the two signals can be correlated via trace and/or span ID.
